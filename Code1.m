% SordilloCode1 -- Sordillo A and Bargmann CI

% These functions will pool the data from all assays.
% Accompanying datasets pool data for simplicity.
% To group data by assay as in our figures
% (1) loop through the Tracks from each of your assays and find the 
% Frequency for each.
% (2) group the Frequency for each assay (we used the mean).

function Frequency=get_frequency(Tracks,t1,t2,FrameRate,reor_type)

% Inputs:
% Tracks - an array that contains the output of .linkedTracks, 
% generated using join_multiple_sansfood_track_arrays on data structures
% generated by BargmannWormTracker
% see Lopez-Cruz et al., 2019
%t1,t2- beggining and end of time window of interest (in minutes)
% FrameRate - framerate of recording that was tracked
% reor_type- the reorientation type that you want to flag as an event (eg 'omega',
% 'upsilon', etc. - 'all' will take any reorientation as an event). See
% mark_reor_events_AS and num_state_convert

%Outputs:
%Vector containing the frequency of the reorientation type (reorientations per worm per
%minute) during a specific time window

  LengthTime=length(t1:t2);

  Frequency = events_per_animal_AS(Tracks,reor_type, t1,t2, FrameRate)/LengthTime;
  
end

%%%%%%%%%%%%%%
%SUBFUNCTIONS%
%%%%%%%%%%%%%%

function vector_events_per_animal = events_per_animal_AS(Tracks,reor_type, t1,t2, FrameRate)

% Adapted from code used in Lopez-Cruz et al., 2019 (original function not
% written by Sordillo A)

% Output: 
% a vector with the number of reorientations for each animal in a specific time window.
%(each element in the vector will represent an animal and the value of each
%element is the number of reorientations for that animal)
%Will only give animals that don't have NaN's in the entire duration of the t1 to t2 time window.

%Inputs:
% Tracks - an array that contains the output of .linkedTracks, 
% generated using join_multiple_sansfood_track_arrays on data structures
% generated by BargmannWormTracker
% see Lopez-Cruz et al., 2019
% reor_type- the reorientation type that you want to flag as an event (eg 'omega',
% 'upsilon', etc. - 'all' will take any reorientation as an event). 
% See num_state_convert
% t1,t2 - beggining and end of time window of interest (in minutes)
% FrameRate- frame rate of acquisition

 [event_matrix,~] = mark_reor_events_AS(Tracks,reor_type, FrameRate); %generates event_matrix See mark_reor_events_AS
 
 if isequal(t1,0)==1
     start = 1; %sets start to 1 if t1=0
 elseif t1 > 0
     start = t1 * FrameRate * 60; %converts t1 from minutes to frames
 end
 
finish = t2 * FrameRate * 60; %converts t2 from minutes to frames
 

events = event_matrix(start:finish,:);%selects the events in the region of interest
full = sum(isnan(events))'; % create 'full' which counts the number of NaNs

vector_events_per_animal = sum (events)';
vector_events_per_animal = vector_events_per_animal(full==0); %only keeps animals that have no NaNs in that time window (where full==0)
 
end

function [event_matrix,time_matrix] = mark_reor_events_AS(Tracks,reor_type,FrameRate)

% Adapted from code used in Lopez-Cruz et al., 2019 (original function not
% written by Sordillo A)

%This type of analysis is to look at the behavior as consisting of reorientation events
%(like Bernoulli trials, 0-fail, 1-success)- in this case 0-fwd
%1-reorientation event

%Inputs
% Tracks - generated by BargmannWormTracker: 
% an array that contains the output of .linkedTracks, 
% generated using join_multiple_sansfood_track_arrays
% see Lopez-Cruz et al., 2019
% reor_type- the reorientation type that you want to flag as an event.
% There are various options here (i)'all'- will take all reorientation as an event
% (ii) 'allnonUpsilon'- will take everything except pure Upsilon and pure Omega (anything but 3.1 or 7.1) (iii) enter a
% specific reorientation string. See num_state_convert. Here you should enter the part of the reorientation that occurs
% first- for example if you're lookign for lRevOmega, you should
% enter 'lRevOmega' as opposed to 'OmegalRev'.
% Options for (iii) are:
% 'lRevOmega' long reversal omega: (the reversals without including turns following them)
% 'sRevOmega' short reversal omega: (the reversals without including turns following them)
% 'lRevUpsilon' long reversal shallow upsilon turn: (the reversals without including turns following them)
% 'sRevUpsilon' short reversal shallow upsilon turn: (the reversals without including turns following them)
% 'pure_Upsilon' shallow turn not coupled to reversal
% 'pure_lRev' long reversal followed by forward movement
% 'pure_sRev' short reversal followed by forward movement
% 'pure_omega' omega turn not coupled to reversal
% 'alllrev' gives all long reversals together (the reversals without including turns following them)
% 'allsrev' gives all short reversals together (the reversals without including turns following them)
% 'allrevomegas' gives all reverals followed by omegas together (the reversals without including turns following them)
% 'allpurerevs' gives all pure revs together (long or short revs that are
% not followed by turns)

%Output
%event_matrix- a matrix (each column is a worm, each row is a frame) 
%that contains '1' where an event occurs for the first time and '0' for the
%rest. The 1 will only be at the frame where the event starts. Frames
%where the track doesn't exist will be filled with NaNs.

%Converts the array into matrices where each column is an animal and each
%row is a frame
Frames = track_field_to_matrix(Tracks, 'Frames')';
Time = Frames ./ FrameRate;
State_matrix_precise = track_field_to_matrix(Tracks, 'State')';
  
State_matrix = floor(State_matrix_precise); %this eliminates decimal points in the state matrix so that fwd and pause are 1

%Creates empty matrix with NaNs
time_matrix = NaN(size(State_matrix)); 
binary_reor = zeros(size(State_matrix));
event_matrix = zeros(size(State_matrix));
event_matrix(isnan(State_matrix_precise)==1) = NaN;

%Will first mark reorientations with a 1 (and the rest of the track is 0).
%What gets marked with a 1 depends on what the reopr_type is.
if strcmpi(reor_type,'all') == 1
   binary_reor(State_matrix ~= 1) = 1; %make anything that isn't forward or pause 1
   binary_reor(State_matrix == 99) = 0; %make the ring zero
   binary_reor(isnan(State_matrix_precise)==1) = NaN; %placing NaNs where the track doesnt exist
   
elseif strcmpi(reor_type,'allnonUpsilon')== 1
   binary_reor(State_matrix ~= 1) = 1; %make anything that isn't forward or pause 1
   binary_reor(abs(State_matrix_precise - 3.1) <0.1) = 0; %Makes upsilons 0
   binary_reor(abs(State_matrix_precise - 7.1) <0.1) = 0; %Makes pure Omega 0
   binary_reor(State_matrix == 99) = 0; %make the ring zero
   binary_reor(isnan(State_matrix_precise)==1) = NaN; %placing NaNs where the track doesnt exist
   
elseif strcmpi(reor_type,'alllrev')== 1
   binary_reor(abs(State_matrix_precise - 4.7) <0.1) = 1; %Makes Lrev of lrevomega 1
   binary_reor(abs(State_matrix_precise - 4.3) <0.1) = 1; %Makes Lrev of lrevups 1
   binary_reor(abs(State_matrix_precise - 4.1) <0.1) = 1; %Makes pure Lrev 1
   binary_reor(isnan(State_matrix_precise)==1) = NaN; %placing NaNs where the track doesnt exist
   
elseif strcmpi(reor_type,'allsrev')== 1
   binary_reor(abs(State_matrix_precise - 5.7) <0.1) = 1; %Makes Srev of srevomega 1
   binary_reor(abs(State_matrix_precise - 5.3) <0.1) = 1; %Makes srev of srevups 1
   binary_reor(abs(State_matrix_precise - 5.1) <0.1) = 1; %Makes pure srev 1
   binary_reor(isnan(State_matrix_precise)==1) = NaN; %placing NaNs where the track doesnt exist
   
elseif strcmpi(reor_type,'allrevomegas')== 1
     binary_reor(abs(State_matrix_precise - 4.7) <0.1) = 1; %Makes Lrev of lrevomega 1
     binary_reor(abs(State_matrix_precise - 5.7) <0.1) = 1; %Makes Srev of srevomega 1
     
elseif strcmpi(reor_type,'allpurerevs')== 1
     binary_reor(abs(State_matrix_precise - 4.1) <0.1) = 1; %Makes pure Lrev 1
     binary_reor(abs(State_matrix_precise - 5.1) <0.1) = 1; %Makes pure srev 1
     
elseif strcmpi(reor_type,'allrevupsilon')== 1
     binary_reor(abs(State_matrix_precise - 4.3) <0.1) = 1; %Makes pure Lrevupsilon 1
     binary_reor(abs(State_matrix_precise - 5.3) <0.1) = 1; %Makes pure srevupsilon 1

else
   pir_value = num_state_convert(reor_type);
   binary_reor(abs(State_matrix_precise - pir_value) <0.01) = 1;
   binary_reor(State_matrix == 99) = 0; %make the ring zero
   binary_reor(isnan(State_matrix_precise)==1) = NaN; %placing NaNs where the track doesnt exist

end


%Will now mark with a '1', only the first frame the reorientation
%starts (event_matrix) and will also record that time (time_matrix)

for k = 1: size(State_matrix,2)
    reor_indices = find(binary_reor(:,k) == 1);
    if isempty(reor_indices) == 0
    event_matrix(reor_indices(1),k) = 1;
    time_matrix(reor_indices(1),k) = Time(reor_indices(1),k);
    end
    for m = 2:length(reor_indices)
        if (reor_indices(m) - reor_indices(m-1)) > 1
            event_matrix(reor_indices(m),k) = 1;
            time_matrix(reor_indices(m),k) = Time(reor_indices(m),k);
        end
    end
end

end

function x = track_field_to_matrix(Tracks, field, nan_replacement)

% This function was deposited with BargmannWormTracker
% See also Lopez-Cruz et al., 2019

% returns a matrix length(Tracks)-by-max(length(Tracks.field)) filled w/
% the value of the field
% NaN for missing values replaced by nan_replacement

x=[];
if(~isfield(Tracks,field))
    return;
end

x = zeros(length(Tracks), max_struct_array(Tracks,'Frames'),'single') + NaN;

for(i=1:length(Tracks))
    x(i,Tracks(i).Frames(1):Tracks(i).Frames(end)) = Tracks(i).(field);
end

% fill the end of each row with the final value instead of NaN
if(nargin==3)
    if(issstr(nan_replacement))
        if(strcmpi(nan_replacement,'end'))
            for(i=1:length(Tracks))
                x(i,Tracks(i).Frames(end):size(x,2)) = Tracks(i).(field)(end);
            end
        end
        return;
    end
    
    if(~issstr(nan_replacement))
        x = matrix_replace(x,'==',NaN,nan_replacement);
    end
end

return;
end

function state = num_state_convert(s)

% This function was deposited with BargmannWormTracker
% See also Lopez-Cruz et al., 2019

state = [];

if(isnumeric(s))
    
    if(length(s)>1)
       for(i=1:length(s))
            state{i} = num_state_convert(s(i));
       end
       return;
    end
    
    if(are_these_equal(s, 1.1))
        state = 'pause'; end
    if(are_these_equal(s, 1))
        state = 'fwd'; end
    if(are_these_equal(s, 2))
        state = 'reori'; end
    if(are_these_equal(s, 3))
        state = 'Upsilon'; end
    if(are_these_equal(s, 4))
        state = 'lRev'; end
    if(are_these_equal(s, 5))
        state = 'sRev'; end
    if(are_these_equal(s, 7))
        state = 'omega'; end
    if(are_these_equal(s, 8))
        state = 'liquid_omega'; end    
    
    if(are_these_equal(s, 4.7))
        state = 'lRevOmega'; end
    if(are_these_equal(s, 7.4))
        state = 'OmegalRev'; end
    
    if(are_these_equal(s, 5.7))
        state = 'sRevOmega'; end
    if(are_these_equal(s, 7.5))
        state = 'OmegasRev'; end
    
    if(are_these_equal(s, 4.3))
        state = 'lRevUpsilon'; end
    if(are_these_equal(s, 3.4))
        state = 'UpsilonlRev'; end
    
    if(are_these_equal(s, 5.3))
        state = 'sRevUpsilon'; end
    if(are_these_equal(s, 3.5))
        state = 'UpsilonsRev'; end
    
    if(are_these_equal(s, 99))
        state = 'ring'; end
    if(are_these_equal(s, 100))
        state = 'missing'; end
    
    if(are_these_equal(s, 200))
        state = 'join'; end
    
    if(are_these_equal(s, 3.1))
        state = 'pure_Upsilon'; end
    if(are_these_equal(s, 4.1))
        state = 'pure_lRev'; end
    if(are_these_equal(s, 5.1))
        state = 'pure_sRev'; end
    if(are_these_equal(s, 7.1))
        state = 'pure_omega'; end
    if(~isempty(state))
        return;
    end
    
    if(s==0)
        state = '';
        return;
    end
    
    error('Cannot find state %.1f\n',s);
end


% is a character array ... return the state code
if(ischar(s))
    switch lower(s)
        case {'ringmiss','missring'} % either ring or missing
            state = 99;
            
        case {'fwdstate', 'fwd_state'}
            state = 1.3;
            
        case {'straight'}
            state = 1.3;
        case {'loop'}
            state = 1.2;
        case {'pause'}
            state = 1.1;
        case {'fwd','forward'}
            state = 1;
            
            
        case {'reori','reorientation'}
            state = 2;
            
        case {'upsilon'}
            state = 3;
        case {'lrev','l_rev','longrev','long_rev'}
            state = 4;
        case {'srev','s_rev','shortrev','short_rev'}
            state = 5;
        case {'omega','om'}
            state = 7;
        case {'liquid_omega','liq_om','liq_omega'}
            state = 8;    
        
        case {'rev'}
            state = [4 5];    
        case {'omega_upsilon', 'upsilon_omega','omegaupsilon','upsilonomega'}
            state = [3 7]; 
            
        case {'pure_upsilon','pureupsilon'}
            state = 3.1;
        case {'pure_lrev','pure_l_rev','pure_longrev','pure_long_rev',...
                'purelrev','purel_rev','purelongrev','purelong_rev' }
            state = 4.1;
        case {'pure_srev','pure_s_rev','pure_shortrev','pure_short_rev',...
                'puresrev','pures_rev','pureshortrev','pureshort_rev' }
            state = 5.1;
        case {'pure_omega','pure_om','pureomega','pureom'}
            state = 7.1;
         
        case {'pure_rev'}
            state = [4.1 5.1];
        case {'pure_omegaupsilon','pure_upsilonomega'}
            state = [3.1 7.1];    
            
        case {'lrevomega','lrev_omega'}
            state = 4.7;
        case {'omegalrev','omega_lrev'}
            state = 7.4;
            
        case {'srevomega','srev_omega'}
            state = 5.7;
        case {'omegasrev','omega_srev'}
            state = 7.5;
            
        case {'lrevupsilon','lrev_upsilon'}
            state = 4.3;
        case {'upsilonlrev','upsilon_lrev'}
            state = 3.4;
            
        case {'srevupsilon','srev_upsilon'}
            state = 5.3;
        case {'upsilonsrev','upsilon_srev'}
            state = 3.5;
            
        case {'nonupsilon_reori','nonupsilon'}
            state = [4.1 5.1 7.1 4.7 5.7 4.3 5.3];
        case {'revomega'}
            state = [4.7 5.7];    
        case {'revupsilon'}
            state = [4.3 5.3];    
        case {'revomegaupsilon','revupsilonomega'} 
            state = [4.7 5.7 4.3 5.3];    
            
        case {'ring'}
            state = 99;
        case {'miss','missing'}
            state = 100;
            
        case {'join'}
            state = 200;
    end
    if(~isempty(state))
        state = single(state);
        return;
    end
    
    error('Cannot find state %s\n',s);
end

return;
end

